#!/bin/bash
# shellcheck shell=bash
set -euo pipefail

# setting default values
: "${RCLONE_REFRESH_METHOD:=default}"
: "${RCLONE_REFRESH_BRACE_EXPANSION:=0}"
: "${DATE_FORMAT:="+%Y/%m/%d %H:%M:%S"}"

# -----------------------------------------------------------------------------
# Logging
# -----------------------------------------------------------------------------
logf() { echo -e "$(date "$DATE_FORMAT") REFRES: $*"; }

# -----------------------------------------------------------------------------
# Prevent concurrent execution using flock
# -----------------------------------------------------------------------------
LOCKFILE="/tmp/$(basename "$0").lock"
exec 9>"$LOCKFILE"
if ! flock -n 9; then
    logf "Already running. Skipping new refresh request."
    exit 3
fi

# -----------------------------------------------------------------------------
# Refresh logic
# -----------------------------------------------------------------------------
refresh_cmd_base=(rclone rc vfs/refresh --url 127.0.0.1:5574 --fast-list --timeout 300m)

do_refresh() {
    local args=("$@")
    local output
    if ! output="$("${refresh_cmd_base[@]}" "${args[@]}" 2>&1)"; then
        logf "rclone rc command failed: $output"
        return 1
    fi

    # parse and log result safely
    if ! jq -r -c 'try (.result | to_entries[] | [.key, .value] | @tsv) catch "parse error"' <<<"$output" 2>/dev/null |
        while IFS=$'\t' read -r dir result; do
            [[ -n "$dir" ]] && logf "\"${dir}\": ${result}"
        done; then
        logf "jq parse failed or invalid rclone output"
        return 1
    fi
}

if [[ $# -lt 1 ]]; then
    exit 0
fi

# 
# main
# 

# RCLONE_REFRESH_METHOD
# 
# - default: a single RC call for multiple dirs using rclone built-in feature
# - individual: multiple RC calls, one for each dir
# 

stime=$(date +%s)

if [ "${1}" == "." ] || [ "${1}" == "/" ]; then
    logf ">>> refreshing root"

    if [ "${RCLONE_REFRESH_METHOD}" == "default" ]; then
        do_refresh "recursive=true"
    else
        while read -r RDIR; do
            if [ "${RCLONE_REFRESH_METHOD}" == "individual" ]; then
                do_refresh "dir=$RDIR" "recursive=true"
            fi
        done <<<"$(find /data -maxdepth 1 -mindepth 1 -type d -print0 | xargs -0 --no-run-if-empty -n1 basename)"
    fi
else
    logf ">>> refreshing \"$1\""

    # replace all newlines with |, then split on |
    IFS="|" read -r -a raw_dirs <<< "${1//$'\n'/|}"

    RDIRS=()
    for dir in "${raw_dirs[@]}"; do
        dir_trimmed="$(echo "$dir" | xargs)"  # remove whitespace
        [[ -n "$dir_trimmed" ]] && RDIRS+=("$dir_trimmed")
    done

    if [ "${RCLONE_REFRESH_BRACE_EXPANSION}" -eq 1 ]; then
        # applying bash brace expansion for a list of vertical-bar-separated paths
        # 1. escape spaces using 'sed -e'
        # 2. apply brace expansion using 'eval printf'
        # 3. readarray from the result of #2 and append to existing one
        expdirs=()
        for RDIR in "${RDIRS[@]}"; do
            readarray -t -O"${#expdirs[@]}" expdirs <<< "$(eval printf '"%s\n"' "${RDIR// /\\ }")"
        done
        RDIRS=("${expdirs[@]}")
    fi

    if [ "${RCLONE_REFRESH_METHOD}" == "default" ]; then
        count=0
        dirs=()
        for RDIR in "${RDIRS[@]}"; do
            count=$((count+1))
            dirs+=("dir$count=$RDIR")
        done
        dirs+=("recursive=true")
        do_refresh "${dirs[@]}"
    else
        for RDIR in "${RDIRS[@]}"; do
            if [ "${RCLONE_REFRESH_METHOD}" == "individual" ]; then
                do_refresh "dir=$RDIR" "recursive=true"
            fi
        done
    fi
fi

etime=$(( $(date +%s) - stime ))
hh=$((etime / 3600))
mm=$(((etime % 3600) / 60))
ss=$(((etime % 3600) % 60))
logf "<<< done in $(printf "%02d:%02d:%02d\n" "$hh" "$mm" "$ss")"
