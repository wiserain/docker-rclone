#!/bin/bash
# shellcheck shell=bash
set -euo pipefail

# -----------------------------------------------------------------------------
# Configuration (environment overrides)
# -----------------------------------------------------------------------------
: "${RCLONE_REFRESH_METHOD:=default}"             # default | individual
: "${RCLONE_REFRESH_BRACE_EXPANSION:=0}"          # 1 = enable brace expansion
: "${DATE_FORMAT:="+%Y/%m/%d %H:%M:%S"}"
: "${RCLONE_REFRESH_MAX_RETRIES:=2}"
: "${RCLONE_REFRESH_RETRY_DELAY:=5}"

[[ -n "${POOLING_FS:-}" ]] && mount_root="/cloud" || mount_root="/data"

# -----------------------------------------------------------------------------
# Logging
# -----------------------------------------------------------------------------
logf() { echo -e "$(date "$DATE_FORMAT") REFRES: $*"; }

# -----------------------------------------------------------------------------
# Prevent concurrent execution using flock
# -----------------------------------------------------------------------------
LOCKFILE="/tmp/$(basename "$0").lock"
exec 9>"$LOCKFILE"
if ! flock -n 9; then
    logf "Already running. Skipping new refresh request."
    exit 3
fi

# -----------------------------------------------------------------------------
# Refresh logic
# -----------------------------------------------------------------------------
refresh_cmd_base=(rclone rc vfs/refresh --url 127.0.0.1:5574 --fast-list --timeout 300m)

if findmnt -t fuse.rclone "$mount_root" >/dev/null 2>&1; then
    check_path=1 # enabled
else
    check_path=0
fi

do_refresh() {
    local args=("$@")
    local output
    if ! output="$("${refresh_cmd_base[@]}" "${args[@]}" 2>&1)"; then
        logf "rclone rc command failed: $output"
        return 1
    fi

    # parse and log result safely
    if ! jq -r -c 'try (.result | to_entries[] | [.key, .value] | @tsv) catch "parse error"' <<<"$output" 2>/dev/null |
        while IFS=$'\t' read -r dir result; do
            [[ -n "$dir" ]] && logf "\"${dir}\": ${result}"
        done; then
        logf "jq parse failed or invalid rclone output"
        return 1
    fi
}

# This function implements a retry loop.
# When mounting Google Drive (especially with shortcuts to other drives), 
# rclone's VFS may not immediately reflect all directory contents after the first refresh. 
# We retry the refresh operation until the directory content is confirmed on the mount path.
do_refresh_with_retry() {
    local RDIR
    RDIR="${1##/}"    # strip all leading /
    RDIR="${RDIR%%/}" # strip all trailing /

    if [[ "$check_path" -eq 0 ]]; then
        do_refresh "dir=$RDIR" "recursive=true"
        return $?
    fi

    local RETRIES=0
	local mount_path="${mount_root}/$RDIR"

    while (( RETRIES <= RCLONE_REFRESH_MAX_RETRIES )); do
        if ! do_refresh "dir=$RDIR" "recursive=true"; then
            return 1 # no need to retry in this case
        fi

        # mount check
        if [ -d "$mount_path" ] && find "$mount_path" -mindepth 1 -maxdepth 1 -print -quit 2>/dev/null | grep -q .; then
            return 0
        fi

        RETRIES=$((RETRIES + 1))
        if (( RETRIES <= RCLONE_REFRESH_MAX_RETRIES )); then
            logf "\"$RDIR\": No content found in \"$mount_path\". Retrying in ${RCLONE_REFRESH_RETRY_DELAY}s... ($RETRIES/$RCLONE_REFRESH_MAX_RETRIES)"
            sleep "$RCLONE_REFRESH_RETRY_DELAY"
        fi
	done

    logf "\"$RDIR\": Refresh failed after $RCLONE_REFRESH_MAX_RETRIES attempts"
	return 1 # exceeded maximum retries
}

# -----------------------------------------------------------------------------
# Main logic
# -----------------------------------------------------------------------------
if [[ $# -lt 1 ]]; then
    exit 0
fi

stime=$(date +%s)

if [[ "$1" == "." || "$1" == "/" ]]; then
    logf ">>> refreshing root"

    if [[ "$RCLONE_REFRESH_METHOD" == "default" ]]; then
        do_refresh "recursive=true"
    else
        while read -r RDIR; do
            if [[ "$RCLONE_REFRESH_METHOD" == "individual" ]]; then
                do_refresh_with_retry "$RDIR"
            fi
        done <<<"$(find "$mount_root" -maxdepth 1 -mindepth 1 -type d -print0 | xargs -0 --no-run-if-empty -n1 basename)"
    fi
else
    logf ">>> refreshing \"$1\""

    # replace all newlines with |, then split on |
    IFS="|" read -r -a raw_dirs <<< "${1//$'\n'/|}"

    RDIRS=()
    for dir in "${raw_dirs[@]}"; do
        dir_trimmed="$(echo "$dir" | xargs)"  # remove whitespace
        [[ -n "$dir_trimmed" ]] && RDIRS+=("$dir_trimmed")
    done

    if (( RCLONE_REFRESH_BRACE_EXPANSION == 1 )); then
        # applying bash brace expansion for a list of vertical-bar-separated paths
        # 1. escape spaces using 'sed -e'
        # 2. apply brace expansion using 'eval printf'
        # 3. readarray from the result of #2 and append to existing one
        expdirs=()
        for RDIR in "${RDIRS[@]}"; do
            readarray -t -O"${#expdirs[@]}" expdirs <<< "$(eval printf '"%s\n"' "${RDIR// /\\ }")"
        done
        RDIRS=("${expdirs[@]}")
    fi

    if [[ "$RCLONE_REFRESH_METHOD" == "default" ]]; then
        count=0
        dirs=()
        for RDIR in "${RDIRS[@]}"; do
            count=$((count+1))
            dirs+=("dir$count=$RDIR")
        done
        dirs+=("recursive=true")
        do_refresh "${dirs[@]}"
    else
        for RDIR in "${RDIRS[@]}"; do
            if [[ "$RCLONE_REFRESH_METHOD" == "individual" ]]; then
                do_refresh_with_retry "$RDIR"
            fi
        done
    fi
fi

etime=$(( $(date +%s) - stime ))
hh=$((etime / 3600))
mm=$(((etime % 3600) / 60))
ss=$(((etime % 3600) % 60))
logf "<<< done in $(printf "%02d:%02d:%02d\n" "$hh" "$mm" "$ss")"
